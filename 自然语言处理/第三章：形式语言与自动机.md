# 形式语法定义

形式语法是一个四元组$\mathbf{G}=(\mathbf{N}, \Sigma, \mathbf{P}, \mathbf{S})$$，其中，$$\mathbb{N}$是非终结符的有限集合（有时也称为变量集or句法种类集）；$\Sigma$是终结符号的有限集合，$\mathbf{N} \cap \Sigma=\Phi$；$\mathbf{V}=\mathbf{N} \cup \Sigma$称为总词汇表；$\mathbf{P}$是一组重写规则的有限集合：$\mathbf{P}=\{\boldsymbol{\alpha} \rightarrow \boldsymbol{\beta}\}$，其中$\alpha, \beta$是由$\mathbf{V}$中元素构成的串，但是$\alpha$至少应含有一个非终结符号；$\mathbf{S} \in \mathbf{N}$称为句子符or初始符

总结下来，就是如下：

* $N$是非终结符集合
* $\Sigma$是终结符集合
* $P$是规则集合
* $S$是初始符

## 定义

设$\mathbf{G}=(\mathbf{N}, \Sigma, \mathbf{P}, \mathbf{S})$是一个文法，在$(\mathbf{N} \cup \Sigma)^{*}
$上定义关系$ \mathop{\Rightarrow}\limits_{G} $(直接派生or推导)，如下：

* 如果$\alpha\beta\gamma$是$(\mathbf{N} \cup \Sigma)^{*}$中的符号串，且$\boldsymbol{\beta} \rightarrow \boldsymbol{\sigma}$是$P$中的一个产生式，那么，$\alpha \beta \gamma$$\mathop{\Rightarrow}\limits_{G} $$\alpha \sigma \gamma$。
* 用$ \stackrel{+}{ \mathop{\Rightarrow}\limits_{G}} $(非平凡方式派生)表示$ \mathop{\Rightarrow}\limits_{G} $的传递闭包，即$(\mathbf{N} \cup \Sigma)^{*}$上的符号串$\xi_{i}$到$\xi_{i+1}$$（i \geq 0）$至少经过一步推导或派生
* 用$ \stackrel{*}{ \mathop{\Rightarrow}\limits_{G}} $(读作派生)表示$ \mathop{\Rightarrow}\limits_{G} $的自反or传递闭包，即由$(\mathbf{N} \cup \Sigma)^{*}$上的符号串$\xi_{i}$到$\xi_{i+1}$经过n$（n \geq 0）$步推导或派生

约定每步推导中只改写最左边的那个非终结符，这种推导称为“最左推导”，反之，如果每次都只改写最右边的非终结符，则为"最右推导"

![](https://raw.githubusercontent.com/Youngy0913/picture_repo/master/img/20190601123326.png)



## 形式语法的类型

文法被划分为4种类型：

* 3型文法(正则文法)
* 2型文法(上下文无关文法)
* 1型文法(上下文有关文法)
* 0型文法(无约束文法)

### 正则文法

如果文法$\mathbf{G}=(\mathbf{N}, \Sigma, \mathbf{P}, \mathbf{S})$的$P$中的规则满足如下形式：$\mathbf{A} \rightarrow \mathbf{B} \boldsymbol{x}$，或$\mathbf{A} \rightarrow \boldsymbol{x}$，其中$\mathbf{A}, \mathbf{B} \in \mathbf{N}, \quad x \in \Sigma$，则称该文法为正则文法，或称3型文法

注：在书写格式中，规则右部的非终结符号出现在最左边，则这种形式的正则文法称为**左线性正则文法**，即$\mathbf{A} \rightarrow \mathbf{B} \boldsymbol{x}$的形式；相对的，如果正则文法的形式如$\mathbf{A} \rightarrow  \boldsymbol{x} \mathbf{B}$，则称为**右线性正则文法**

![](https://raw.githubusercontent.com/Youngy0913/picture_repo/master/img/20190601130556.png)

***

### 上下文无关文法(CFG)

如果$P$中的规则满足如下形式：$\mathbf{A} \rightarrow \alpha$，其中$\mathbf{A} \in \mathbf{N}, \quad \alpha \in(\mathbf{N} \cup \Sigma) *$，则称该文法为上下文无关文法(CFG)，或称2型文法

![](https://raw.githubusercontent.com/Youngy0913/picture_repo/master/img/20190601130922.png)

***

### 上下文有关文法(CSG)

如果$P$中的规则满足如下形式：$\alpha \mathrm{A} \beta \rightarrow \alpha \gamma \beta$，其中$\mathbf{A} \in \mathbf{N}, \quad \alpha, \beta, \gamma \in(N \cup \Sigma) *$，且$\gamma$至少包含一个字符，则称该文法为上下文有关文法(CSG)，或称1型文法

另外一种定义：if $x \rightarrow y, x \in(N \cup \Sigma)^{+}$，$y \in(N \cup \Sigma) *$，并且$|y| \geq|x|$

![](https://raw.githubusercontent.com/Youngy0913/picture_repo/master/img/20190601221600.png)

***

### 无约束文法

如果$P$中的规则满足如下形式：$\alpha \rightarrow \beta$，$\alpha, \beta$是字符串，则称$G$为无约束文法，或称0型文法

### 结论

显然，每一个正则文法都是上下文无关文法，每一个上下无关文法都是上下文有关文法，而每一个上下文有关文法都是0型文法，即$\mathbf{L}(\mathbf{G} \mathbf{0}) \supseteq \mathbf{L}(\mathbf{G} \mathbf{1}) \supseteq \mathbf{L}(\mathbf{G} \mathbf{2}) \supseteq \mathbf{L}(\mathbf{G} \mathbf{3})$



## CFG产生的语言句子的派生树表示

$\mathbf{G}=(\mathbf{N}, \Sigma, \mathbf{P}, \mathbf{S})$产生一个句子的派生树由如下步骤构成：

1. 对于$\forall x \in N \cup \Sigma$给一个标记作为节点，$S$作为树的根节点
2. 如果一个节点的标记为A，并且它至少有一个除它自身以外的后裔，则$\mathbf{A} \in \mathbf{N}$
3. 如果一个节点的标记为A，它的$k(k>0)$个直接后裔节点按从左到右的次序依次标记为$\mathbf{A}_{1}, \mathbf{A}_{2}, \dots, \mathbf{A}_{\mathbf{k}}$，则$\mathbf{A} \rightarrow\mathbf{A}_{1} \mathbf{A}_{2} \ldots \mathbf{A}_{\mathbf{k}}$一定是$P$中的一个产生式

![](https://raw.githubusercontent.com/Youngy0913/picture_repo/master/img/20190601221635.png)

***

## CFG的二义性

一个文法$G$，如果存在某个句子有不止一颗分析树与之对应，那么称这个文法是二义的

![](https://raw.githubusercontent.com/Youngy0913/picture_repo/master/img/20190601133113.png)

![](https://raw.githubusercontent.com/Youngy0913/picture_repo/master/img/20190601133234.png)

![](https://raw.githubusercontent.com/Youngy0913/picture_repo/master/img/20190601133204.png)

所以，派生树1是：关于（鲁迅的文章），派生树2是：（关于鲁迅）的文章

***



# 有限自动机和正则文法

## 确定的有限自动机(DFA)

确定的有限自动机$M$是一个五元组：$\mathbf{M}=\left(\Sigma, \mathbf{Q}, \delta, \mathbf{q}_{0}, \mathbf{F}\right)$

* $\Sigma$是输入符号的有穷集合
* $Q$是状态的有限集合
* $\mathbf{q}_{0} \in \mathbf{Q}$是初始状态
* $\mathbf{F}$是终止状态集合，$\mathbf{F} \subseteq \mathbf{Q}$
* $\delta$是$Q$与$\Sigma$的直积$\mathbf{Q} \times \Sigma$到$Q$(下一个状态) 的映射。它支配着有限状态控制的行为，有时也称为**状态转移函数**



**DFA示意图**

![](https://raw.githubusercontent.com/Youngy0913/picture_repo/master/img/20190601161930.png)

处在状态$\mathbf{q} \in \mathbf{Q}$中的有限控制器从左到右依次从输入带上读入字符。开始时有限控制器处在状态$q0$，并注视$\sum^{*}$中一个链的最左符号。映射$\delta(\mathbf{q}, \mathbf{a})=\mathbf{q}^{\prime}\left(\mathbf{q}, \mathbf{q}^{\prime} \in \mathbf{Q}\right. ,\mathbf{a} \in \Sigma )$表示在状态$q$ 时，若输入符号为$ a$，则自动机进入状态$ q’$ 并且将输入头向右移动一个字符



**状态变换图**

映射$\delta(q, a)=q^{\prime}$可以由状态变换图描述，为了明确起见，终止状态用双圈表示，起始状态用有“开始”标记的箭头表示，如下：

![](https://raw.githubusercontent.com/Youngy0913/picture_repo/master/img/20190601221710.png)

**DFA定义的语言**

如果一个句子$\mathbf{X}$使得有限自动机$\mathbf{M}$有$\delta\left(\mathbf{q}_{0}, \mathbf{x}\right)=\mathbf{p}, \mathbf{p} \in \mathbf{F}$，那么，称句子$\mathbf{X}$被$\mathbf{M}$接受。由$M$定义的语言$\mathbf{T}(\mathbf{M})$就是被$\mathbf{M}$接受的句子的全集，即：
$$
\mathbf{T}(\mathbf{M})=\left\{\mathbf{x} | \delta\left(\mathbf{q}_{0}, \mathbf{x}\right) \in \mathbf{F}\right\}
$$
![](https://raw.githubusercontent.com/Youngy0913/picture_repo/master/img/20190601163033.png)

***

## 不确定的有限自动机(NFA)

不确定的有限自动机$M$是一个五元组：$\mathbf{M}=\left(\Sigma, \mathbf{Q}, \delta, \mathbf{q}_{0}, \mathbf{F}\right)$

- $\Sigma$是输入符号的有穷集合
- $Q$是状态的有限集合
- $\mathbf{q}_{0} \in \mathbf{Q}$是初始状态
- $\mathbf{F}$是终止状态集合，$\mathbf{F} \subseteq \mathbf{Q}$
  - 注：$\mathbf{F}$有n种可能
- $\delta$是$Q$与$\Sigma$的直积$\mathbf{Q} \times \Sigma$到$Q$的幂集 $2^\mathrm{Q}$的映射

***

## DFA和NFA的区别

NFA 与 DFA 的唯一区别是：

* 在 NFA 中$\delta(\mathbf{q}, \mathbf{a})$是一个状态集合，而在DFA中$\delta(\mathbf{q}, \mathbf{a})$是一个状态

![](https://raw.githubusercontent.com/Youngy0913/picture_repo/master/img/20190601163533.png)

**定理**：设 $L$ 是一个被 NFA 所接受的句子的集合，则存在一个DFA，它能够接受 $L$  

**说明**：由于 DFA 与 NFA 所接受的是同样的链集，所以一般情况下无需区分它们，二者统称为有限自动机 (finite automata, FA)



## 正则文法与有限自动机的关系

**定理**：若$\mathbf{G}=\left(\mathbf{V}_{\mathbf{N}}, \mathbf{V}_{\mathbf{T}}, \mathbf{P}, \mathbf{S}\right)$是一个正则文法，则存在一个有限自动机$\mathbf{M}=\left(\Sigma, \mathbf{Q}, \delta, \mathbf{q}_{0}, \mathbf{F}\right)$，使得 ：
$$
\mathbf{T}(\mathbf{M})=\mathbf{L}(\mathbf{G})
$$


### 由正则文法$G$ 构造有限自动机$M$

**由正则文法$G$ 构造有限自动机$M$ 的一般步骤：**

1. 令$\Sigma=\mathbf{V}_{\mathrm{T}}, \mathbf{Q}=\mathbf{V}_{\mathbf{N}} \cup\{\mathbf{T}\}, \mathbf{q}_{0}=\mathbf{S}$，其中，$T$是一个新增加的非终结符

2. 如果在 P 中有产生式$\mathbf{S} \rightarrow \boldsymbol{\varepsilon}$，则$\mathbf{F}=\{\mathbf{S}, \mathbf{T}\}$，否则$\mathrm{F}=\{\mathrm{T}\}$

3. 如果在 P 中有产生式$\mathbf{B} \rightarrow \mathbf{a}$，$\mathbf{B} \in \mathbf{V}_{\mathbf{N}}, \quad \mathbf{a} \in \mathbf{V}_{\mathbf{T}}$，则$\mathbf{T} \in \delta(\mathbf{B}, \mathbf{a})$

   注：B推导出a，然后就完事了 

4. 如果在 P 中有产生式$\mathbf{B} \rightarrow \mathbf{a} \mathbf{C}$，$\mathbf{B}, \mathbf{C} \in \mathbf{V}_{\mathbf{N}}$，$\mathbf{a} \in \mathbf{V}_{\mathrm{T}}$，则$\mathbf{C} \in \delta(\mathbf{B}, \mathbf{a})$

   注：B接受一个输入a，到达状态C，C还可以继续往下走

5. 对于每一个$\mathbf{a} \in \mathbf{V}_{\mathbf{T}}$，有$\delta(\mathrm{T}, \mathrm{a})=\phi$

   注：每一个符号都是终止符号，则到达空的状态，实际上这条没用，只是为了算法的完整性

注：$\mathbf{V}_{\mathrm{T}}$是终止符号集合$\Sigma$，$\mathbf{V}_{\mathrm{N}}$是非终止符集合$N$，$Q$是$\mathbf{V}_{\mathrm{N}}$增加了状态$T$后的状态集合，而非终止符是输入符号，$\varepsilon$是空符号，我们最终想要的是从非终止符$N$到终止符$\Sigma$，$\mathbf{T} \in \delta(\mathbf{B}, \mathbf{a})$似乎表明的是$\delta(B, a)=\{T\}$，只是猜想，还不是特别能肯定



![](https://raw.githubusercontent.com/Youngy0913/picture_repo/master/img/20190601190656.png)

注：规则P里的$\mathbf{B} \rightarrow \mathbf{b S | a B | a}$表示$\mathbf{B} \rightarrow \mathbf{b S}$，$\mathbf{B} \rightarrow \mathbf{a B}$，$\mathbf{B} \rightarrow \mathbf{a}$三种规则

![](https://raw.githubusercontent.com/Youngy0913/picture_repo/master/img/20190601221801.png)

注：

* 第一步是先确定各个终止符和非终止符，并且增加一个$T$，第二步也就开始找映射关系了
* 第三条映射，$\delta(\mathbf{B}, \mathbf{a})=\{\mathbf{B}, \mathbf{T}\}$是一个合在一起的结果，其中$\mathbf{B} \rightarrow \mathbf{a B}$让映射$\delta(B, a)=\{B\}$，然后根据前面算法的内容，再加上$\mathbf{B} \rightarrow \mathbf{a}$，可以得到$\delta(B, a)=\{T\}$，最后合在一起就可以得到$\delta(\mathbf{B}, \mathbf{a})=\{\mathbf{B}, \mathbf{T}\}$

接着，画出图像如下：

![](https://raw.githubusercontent.com/Youngy0913/picture_repo/master/img/20190601193658.png)

 

### 由有限自动机$M$构造正则文法$G$ 

由有限自动机$M$构造正则文法$G$的的一般步骤：

1. 令$\mathbf{V}_{\mathbf{N}}=\mathbf{Q}, \quad \mathbf{V}_{\mathbf{T}}=\Sigma, \quad \mathbf{S}=\mathbf{q}_{0}$
2. 如果$\mathbf{C} \in \delta(\mathbf{B}, \mathbf{a}), \mathbf{B}, \mathbf{C} \in \mathbf{Q}, \mathbf{a} \in \Sigma$，则在$P$中有产生式$\mathbf{B} \rightarrow \mathbf{a} \mathbf{C}$
3. 如果$\mathbf{C} \in \delta(\mathbf{B}, \mathbf{a}), \quad \mathbf{C} \in \mathbf{F}$，则在$P$中有产生式$\mathbf{B} \rightarrow \mathbf{a}$



# 下推自动机与上下文无关文法（CFG）

## 下推自动机(PDA)

PDA 可以看成是一个带有附加的下推存储器的有限自动机，下推存储器是一个栈。如下图所示：

![](https://raw.githubusercontent.com/Youngy0913/picture_repo/master/img/20190601194922.png)

 注：下推存储器类似于一个栈 

**PDA定义**：

一个不确定的PDA可以表达成一个7元组$\mathbf{M}=\left(\Sigma, \mathbf{Q}, \Gamma, \delta, \mathbf{q}_{0}, \mathbf{Z}_{0}, \mathbf{F}\right)$

* $\Sigma$是输入符号的有穷集合

* $Q$是状态的有限集合

* $\Gamma$为下推存储器符号的有穷集合

  注：即栈里面要放的东西 

* $\mathbf{q}_{0} \in \mathbf{Q}$是初始状态

* $\mathbf{Z}_{0} \in \Gamma$为最初出现在下推存储器顶端的符号

* $F$是终止状态集合，$\mathbf{F} \subseteq \mathbf{Q}$

* $\delta$是从$\mathbf{Q} \times(\Sigma \cup\{\varepsilon\}) \times \Gamma$到$\mathbf{Q} \times \Gamma^{*}$子集的映射

  注：之前的有限自动机是从一个状态接收到一个输入就直接到下一个状态了，然而这里的映射不再那么简单，而是在输入$\Sigma$中 考虑了$\varepsilon$(即空的情况)，并且也考虑到了下推存储器，即栈里面$\Gamma$的情况，然后才到下一个状态 



映射关系$\delta$的解释：

* 映射关系$\delta(\mathbf{q}, \mathbf{a}, \mathbf{Z})=\left\{\left(\mathbf{q}_{1}, \gamma_{1}\right),\left(\mathbf{q}_{2}, \gamma_{2}\right), \ldots,\left(\mathbf{q}_{\mathbf{m}}, \gamma_{\mathbf{m}}\right)\right\}$，其中
  * $\mathbf{q}_{1}, \mathbf{q}_{2}, \ldots, \mathbf{q}_{\mathbf{m}} \in \mathbf{Q}$，即状态集合
  * $\mathbf{a} \in \Sigma$，即输入符号
  * $\mathbf{z} \in \Gamma$，  $\mathbf{z}$相当于符号集合
  * $\gamma_{1}, \gamma_{2}, \ldots, \gamma_{\mathrm{m}} \in \Gamma^{*}$是栈内集合，这样的符号构成的串，这是一个*闭包， 这些串是由这些符号构成的
* 该映射的意思是：当PDA处于状态q时，面临输入符号a时，自动机将进入某一个状态$\mathbf{q}_{\mathbf{i}}, \mathbf{i}=\mathbf{1}, 2, \ldots, \mathbf{m}$，即共有m个状态，并以$\gamma_{\mathrm{i}}$来代替下推存储器(栈)顶端符号Z，同时将输入头指向下一个字符，也就是Z弹出来，$\gamma_{\mathrm{i}}$压进去。而当Z被$\gamma_{\mathrm{i}}$取代时，$\gamma_{\mathrm{i}}$的符号按照从左到右的顺序依次从下向上推入到存储器
* 特殊情况下，当$\delta(\mathbf{q}, \varepsilon, \mathbf{Z})=\left\{\left(\mathbf{q}_{1}, \gamma_{1}\right),\left(\mathbf{q}_{2}, \gamma_{2}\right), \ldots,\left(\mathbf{q}_{\mathrm{m}}, \gamma_{\mathrm{m}}\right)\right\}$时，输入头位置不移动，只用于处理下推存储器内部的操作，叫做"$\varepsilon$移动"，即这个状态不接受任何输入时，要改变栈里面的东西



下推自动机的符号约定

设有序对$(\mathbf{q}, \gamma), \mathbf{q} \in \mathbf{Q}, \gamma \in \mathbf{\Gamma}^{*}$，对于$\mathbf{a} \in\left(\sum \cup\{\boldsymbol{\varepsilon}\}\right), \boldsymbol{\beta} \in \mathbf{\Gamma}^{*}, \mathbf{Z} \in \mathbf{\Gamma}$，如果$\left(\mathbf{q}^{\prime}, \boldsymbol{\beta}\right) \in \boldsymbol{\delta}(\mathbf{q}, \mathbf{a}, \mathbf{Z}), \mathbf{q}^{\prime}, \mathbf{q} \in \mathbf{Q}$，则表达式
$$
\mathbf{a} :\left.(\mathbf{q}, \mathbf{Z} \gamma)\right|_\overline{\mathbf{M}}\left(\mathbf{q}^{\prime}, \beta \gamma\right)
$$
表示根据下推自动机的状态变换规则，输入 a 能使下推自动机$M$由格局$(\mathbf{q}, \mathbf{Z} \gamma)$变换到格局$\left(\mathbf{q}^{\prime}, \beta \gamma\right)$,或称$\mathbf{a} :\left.(\mathbf{q}, \mathbf{Z} \gamma)\right|_\overline{\mathbf{M}}\left(\mathbf{q}^{\prime}, \beta \gamma\right)$为合法转移，零次或多次合法转移记为$\mathbf{a} :\left.(\mathbf{q}, \mathbf{Z} \gamma)\right|_\overline{\mathbf{M}} ^{*}\left(\mathbf{q}^{\prime}, \boldsymbol{\beta} \gamma\right)$，其中$M$可以省略不写，而至少一次转移记为$\mathbf{a} :\left.(\mathbf{q}, \mathbf{Z} \gamma)\right|_\overline{\mathbf{M}} ^{+}\left(\mathbf{q}^{\prime}, \boldsymbol{\beta} \gamma\right)$

注：

* $\left(\mathbf{q}^{\prime}, \boldsymbol{\beta}\right) \in \boldsymbol{\delta}(\mathbf{q}, \mathbf{a}, \mathbf{Z}), $表示$\mathbf{q}^{\prime}$接收到输入$\beta$就属于这个映射，就相当于$q$这个状态接收到$a$的输入时，栈里的存储器是$Z$这些符号，最后就到达$\mathbf{q}^{\prime}$这个状态，再用$\beta$改写存储器里的东西，即$\beta$符号要放到栈里去
* $\Gamma^{*}$和$\Gamma^{+}$一样，只是$\Gamma^{+}$没有$\phi$，比如$\Gamma=\{a, b\}$,$\Gamma^{+}=\{a, b,ab,ba,aaa,···\}$,而$\Gamma^{*}=\{\phi，a, b，ab,ba,aaa,···\}$



**下推自动机所接受的语言**

![](https://raw.githubusercontent.com/Youngy0913/picture_repo/master/img/20190601211627.png)

注：从$q_{0}$的初始状态开始推，能够接收的所有的符号串都走完了，而正好到达终止状态时（或者栈里面是空的），所有的这些串都是自动机所接受的语言，这个语言构成的集合我们就称为$\mathbf{T}(\mathbf{M})$

![](https://raw.githubusercontent.com/Youngy0913/picture_repo/master/img/20190601211852.png)

注：开始时栈是空，我们经过(1)，把A压入栈内，状态还是0；经过(2)时，状态是0，接受到b，栈内是A，于是我们状态转移后还是状态0，此时我们将栈原先的A弹出，用AB替换，即从左到右依次压入栈内

![](https://raw.githubusercontent.com/Youngy0913/picture_repo/master/img/20190601214836.png)



# 语言类型和识别器的对应关系

![](https://raw.githubusercontent.com/Youngy0913/picture_repo/master/img/20190601215503.png)